# StateBase Developer Context (llm.txt)
# Generated: 2026-01-28
# Purpose: Context for AI Agents to integrate with StateBase

---

## 1. What is StateBase?

StateBase is an infrastructure-as-a-service for **AI State Management**. It provides persistent memory, session tracking, and audit trails for LLM agents.

**Core Mental Model:**
Instead of managing a raw Vector DB or chat history list, you offload the entire "Context Window Management" to StateBase.
1.  **Read Phase**: You ask StateBase "What does this user need to know right now?" (Retrieval).
2.  **Act Phase**: You run your LLM logic.
3.  **Write Phase**: You tell StateBase "Here is what just happened." (Ingestion).

---

## 2. Installation & Auth

### Python SDK
```bash
pip install statebase-sdk
```

### TypeScript SDK
```bash
npm install @statebase/client
```

### Authentication
Get your API Key from `https://app.statebase.org`.
Pass it via `STATEBASE_API_KEY` env var or constructor.

---

## 3. The "Amalthea" Integration Pattern

This is the standard pattern for building reliable agents with StateBase.

### Step 1: Initialize
```python
from statebase import StateBase
sb = StateBase(api_key="sb_live_...")
```

### Step 2: Start/Retrieve Session
A **Session** (`sess_...`) is the container for a conversation thread.
```python
session = sb.sessions.create(
    agent_id="my_coding_assistant",
    user_id="user_123" 
)
```

### Step 3: The Interaction Loop
Do NOT maintain a local list of messages. Let StateBase construct the context.

```python
# 1. USER INPUT
user_query = "What is my preferred coding style?"

# 2. GET CONTEXT (Retrieval)
# StateBase returns a simplified object optimized for system prompts.
# It includes:
# - 'memories': Relevant long-term facts (RAG)
# - 'state': Current state variables
# - 'recent_history': Last N turns
context = sb.sessions.get_context(
    session_id=session.id,
    query=user_query
)

# 3. CONSTRUCT PROMPT
# Inject the retrieved context into your LLM's system prompt.
system_prompt = f"""
You are a helpful assistant.
Context:
{context.to_str()}
"""

# 4. CALL LLM
response = openai.chat.completions.create(
    model="gpt-4",
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_query}
    ]
)
ai_reply = response.choices[0].message.content

# 5. LOG TURN (Ingestion)
# This triggers the background Memory extraction (SNAP algorithm).
sb.sessions.add_turn(
    session_id=session.id,
    input=user_query,
    output=ai_reply
)
```

---

## 4. Concepts & Data Models

### Sessions (`sess_...`)
Top-level container.
*   `id`: Unique identifier (String)
*   `user_id`: The end-user (String)
*   `agent_id`: The ID of your agent logic (String)
*   `state`: JSON object representing current variables (e.g. `{"step": "onboarding"}`).

### Turns (`turn_...`)
An atomic interaction. Immutably recorded.
*   `input`: User message (Text/JSON)
*   `output`: Agent response (Text/JSON)
*   `metadata`: Token counts, latency, model name.

### Memory (`mem_...`)
Semantic facts stored in the Knowledge Graph.
*   **Scopes**:
    *   `session`: Cleared when session ends.
    *   `user`: Persists for that `user_id` forever.
    *   `agent`: Read-only knowledge base for the `agent_id`.

---

## 5. API Reference (REST)

If using the SDK is not possible, use the REST API.
**Base URL**: `https://api.statebase.org/v1`

### `POST /sessions`
Create a new session.
```json
{ "agent_id": "bot_v1", "user_id": "user_99" }
```

### `POST /sessions/{id}/context`
Retrieve context for generation.
**Request**: `{ "query": "hello" }`
**Response**:
```json
{
  "state": { ... },
  "memories": ["User prefers Python"],
  "turns": [ ... ]
}
```

### `POST /sessions/{id}/turns`
Log an interaction.
```json
{
  "input": { "content": "hello" },
  "output": { "content": "hi there" }
}
```

### `POST /memories`
Manually inject a fact (e.g. from a form).
```json
{
  "user_id": "user_99",
  "content": "User lives in New York",
  "scope": "user"
}
```

---

## 6. Advanced Features

### Manual State Update
You can explicitly update the state JSON without logging a turn (e.g. when a background tool finishes).
```python
sb.sessions.update_state(
    session_id="sess_123",
    state={"cart_items": ["apple", "banana"]}
)
```

### Rollback (Undo)
If the agent makes a mistake, revert the session to a previous turn.
```python
sb.sessions.rollback(
    session_id="sess_123",
    turn_id="turn_before_error"
)
```
This orphans the bad turn but keeps it for audit logs.

### Traceability
All actions are logged. You can view them in the dashboard to debug "Why did the agent say that?".
